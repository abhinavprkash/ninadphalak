package kargerMinCut;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.Set;

public class KargerMinCut {
/*	Karger Algorithm:
	1)  Initialize contracted graph G as copy of original graph
	2)  While there are more than 2 vertices.
	      a) Pick a random edge (u, v) in the contracted graph.
	      b) Merge (or contract) u and v into a single vertex (update 
	         the contracted graph).
	      c) Remove self-loops
	3) Return cut represented by two vertices.
*/
	
	public static int kargerMinCut(Graph graph){
		while(getNumOfVertices(graph) > 2){
			/* To pick a random edge, we will pick a random key i.e vertex and then iterate over the value and pick a random node
			 * So our (vertex,node) will be the random edge selected
			 */
			Node[] randomEdge = getRandomEdge(graph);
			//System.out.println("Random Edge is: " + randomEdge[0].toString() + ", " + randomEdge[1].toString());
			contract(graph, randomEdge);
			
		}
		return 0;
	}
	
	public static Node[] getRandomEdge(Graph graph){

		Node[] edge = new Node[2];
		Random rand = new Random();
		int randomIndex = rand.nextInt(graph.adjMap.keySet().size());
		int i = 0;
		//**iterate over the graph keys(vertices) until i == randomIndex**
		for(Node n : graph.adjMap.keySet()){
			if(i == randomIndex){
				edge[0] = n;
			}
			i++;
		}

		ArrayList<Node> rndNodeValues =	graph.adjMap.get(edge[0]);
		int randomIndex2 = rand.nextInt(rndNodeValues.size());
		edge[1] = rndNodeValues.get(randomIndex2);
		return edge;
		
	}
	
	public static void contract(Graph graph, Node[] edge){
		ArrayList<Node> startVertexAdjList = graph.adjMap.get(edge[0]);
		ArrayList<Node> endVertexAdjList = graph.adjMap.get(edge[1]);
		graph.adjMap.remove(edge[0]);
		graph.adjMap.remove(edge[1]);
		
	}
	
	public static int getNumOfVertices(Graph g){
		//number of vertices = total number of keys in G
		return g.adjMap.size();
	}
}
